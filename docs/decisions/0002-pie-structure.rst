1. Structure of the Program Intent Engagement Service
=====================================================

Status
------

Accepted

What is a Program Intent?
-------------------------

A program intent records a **learner's** **intent** to complete a **program**. That intent can be positive or negative, certain or uncertain. Each intent also records the **reason** we are storing the intent, such as package purchase or completion of courses within the program.

Intents are never modified. If new information gives us a new belief about the learner's intentions, we write a new intent for that learner and program, leaving the old one in place. Intents have two timestamps to assist with ordering, the standard **created** timestamp and an **effective** timestamp which is the time this intent became true to the system. If a weekly batch job on Saturday were to notice that the user had signed up for a program on Tuesday, created would be Saturday, and effective would be Tuesday.

Model
+++++

+--------------------+----------------------------------------+
|Data                |Note                                    |
+====================+========================================+
|Program Identifier  |the program UUID is the identifier we're|
|                    |most likely to use                      |
+--------------------+----------------------------------------+
|Learner ID          |the User ID                             |
+--------------------+----------------------------------------+
|Reason              |i.e. ALL_COURSES_COMPLETE or            |
|                    |BUNDLE_PUCRHASE                         |
+--------------------+----------------------------------------+
|Certainty           |CERTAIN_YES, CERTAIN_NO or MAYBE        |
|                    |                                        |
+--------------------+----------------------------------------+
|Effective Time      |when did the event occur that made this |
|                    |intent                                  |
+--------------------+----------------------------------------+
|Bookkeeping fields  |ID, created date, etc                   |
|for Django          |                                        |
+--------------------+----------------------------------------+

API
---

Writes
++++++


MVP
~~~

We need a simple write event call, something like:

POST /programintent (user ID, program ID, reason, certainty, optional effective time if not NOW)

This will write an intent to the store if there is not already an intent for this user/program/type/date. This lets us start writing UIs which ask about intent.

To bootstrap our intents we also need a management command to load intents generated by reports:

LoadAllTheseProgramIntents (intent file)


Later Work
~~~~~~~~~~

As a replacement for the management command we will connect a pipeline from the data warehouse to the PIE service. This will remove the periodic manual update we'll be using during the MVP.

Even later when event bus is ready, the PIE service can listen to enrollment or purchase events to immediately mark some intents. This would let us give quick feedback that we can’t do via batch job even if the user is not directly telling us their intent. We could do this work by adding intent code all over enrollments and purchase but that would make too much of the code PIES aware and tangle everything together.


Reads
+++++

MVP
~~~

Our first projected use for program intent is UI customization. For that we want a read call which prefers certain intents over maybes.

The hypothetical name for this is “latest and most certain”. This call is made on behalf of the user. For each program in the set of user intents, it returns:

* The latest (by effective date) CERTAIN_YES or CERTAIN_NO intent
* If there is no such record, the latest MAYBE intent


Later Work
~~~~~~~~~~

Once we have more uses for program intents, we’ll want more read calls, but we don’t know what those are currently. It seems more likely that we will want targeted calls than a generic "get all intents" call.

